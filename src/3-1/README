You may run this code on a small example data or the data in our paper (large).
To download the large data, please go to http://www.csie.ntu.edu.tw/~r00922051/matching/
All of the following commands are tested on 64-bit linux server with bash shell (python, g++, matlab installed)
Please contact r00922051+matching@csie.ntu.edu.tw if you have any questions.

In all cases, the testing file is only used for evaluation purpose and never used while building the model.
In case when the testing file is not available, just replace the argument with the validation file name.

##################### RUNNING on the SMALL EXAMPLE DATA ###########
0_genExampleData/:	generate example data
	An synthetic data is provided as an example.
	In the data, there are 2000 users and 1000 items in R1 and R2.
	And user matching is
	R1         R2
	1    <-> 2000
	2    <-> 1999
	... 
	2000 <->    1
	
	item matching is
	R1         R2
	1    <-> 1000
	2    <->  999
	... 
	1000 <->    1

	The rank is 5, and R1 and R2 are of the disjoint split scenario.
	
	The data file (R1_train.example, R1_valid.example, R2_train.example, R2_valid.example, test.example) can be generated by
		matlab -r "genRatingMat;exit"
		python gen.py
	
	
1_MF/:			regular matrix factorization 
	MF.cpp is the code for regular matrix factorization (in C++)
	There are two paremeters in MF: regularization term (lambda) and number of latent factors (K).
	lambda needs to be tuned by observing validation RMSE.
	
	For example, to run on the example data, first modify the number of latent factors in the code MF.cpp
		static const int nFEATURE = 50;
	change it into the following:
		static const int nFEATURE = 5;
	Also, the example data is very small, so the result may be bad with some random seeds. 
	To avoid that, change the following:
		srand((unsigned)time(NULL));
	into
		srand(100);
	Then type
		g++ -std=c++11 MF.cpp -o MF
		./MF 0 ../0_genExampleData/R1_train.example ../0_genExampleData/R1_valid.example ../0_genExampleData/R1_valid.example  &> log_R1 &
		./MF 0 ../0_genExampleData/R2_train.example ../0_genExampleData/R2_valid.example ../0_genExampleData/R2_valid.example  &> log_R2 &
	where 0 is the lambda value that should be tuned by observing the validation RMSE in the log.
	
	After they finish, model files will be generated.
	You can type the following to get P and Q out of the model file
		cat R1_train.example_vali_model.txt | ./toP.sh > R1_P
		cat R1_train.example_vali_model.txt | ./toQ.sh > R1_Q
		cat R2_train.example_vali_model.txt | ./toP.sh > R2_P
		cat R2_train.example_vali_model.txt | ./toQ.sh > R2_Q
	
	

2_latentSpaceMatching_and_matchingRefinement:	latent space matching and matching refinement
	The matching part is written in matlab (2009) and a mex function (c++), so remember to do ''mex -setup'' to set the compiler.

	To run our matching algorithm, first we need to tell it how users/items are matched between R1 and R2 so our program can calculate the accuracy for us.
	For this small example, you need to modify the following (even though this will not affect the matching result):
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	In findMappingByUV.m , change 
		if isequal(type, 'User')
		        lenP1 = 20001;
		else
		        assert(isequal(type, 'Item'))
		        lenP1 = 10001;
		end
	into 
		if isequal(type, 'User')
		        lenP1 = 2001;
		else
		        assert(isequal(type, 'Item'))
		        lenP1 = 1001;
		end

	In findMapping_match.cpp , change
        	if(strcmp(matchingType, "User") == 0)
			ans = 20000-1-indexInA;
		else if(strcmp(matchingType, "Item") == 0)
			ans = 10000-1-indexInA;
	into 
        	if(strcmp(matchingType, "User") == 0)
			ans = 2000-1-indexInA;
		else if(strcmp(matchingType, "Item") == 0)
			ans = 1000-1-indexInA;

	In two_block_search.m , change
		if isequal(type,'User')
		        lenP1 = 20001;
		else
		        assert(isequal(type,'Item'))
		        lenP1 = 10001;
		end
	into
		if isequal(type,'User')
		        lenP1 = 2001;
		else
		        assert(isequal(type,'Item'))
		        lenP1 = 1001;
		end
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	On the other hand, we use parallel toolbox for speed up (matlabpool), if you don't have it, simply comment out the following lines in two_block_search.m :
		%if matlabpool('size') == 0 % for parallel computing
		%   matlabpool
		%end


	Then, type the following commands in matlab
		>> [idxP idxQ] = two_block_search(load('../0_genExampleData/R1_train.example'), load('../0_genExampleData/R1_valid.example'), load('../0_genExampleData/test.example'), load('../1_MF/R1_P'), load('../1_MF/R1_Q'), load('../0_genExampleData/R2_train.example'), load('../1_MF/R2_P'), load('../1_MF/R2_Q'), 5, 500);
		>> dlmwrite('idxP', idxP);
		>> dlmwrite('idxQ', idxQ);
	
	5 is the number of latent factors (K) and 500 is the number of candidates (C).
	idxP and idxQ are the result of user matching and item matching.
	For example, if the first line of idxP is 2000, that means the first user in R1 maps to the 2000th user in R2.

	For this small example data, you should get 100% matching accuracy.



3_ratingPredictionWithMatching:		transferring imperfect matching to perdict ratings on the target domain
	Again, since the example data is small, to avoid bad initialization, add this into the first line of main function in combinedMF.cpp
		srand(10);

	To run, please type
		g++ -std=c++11 combinedMF.cpp -o combinedMF
		beta=100
		./combinedMF ../0_genExampleData/R1_train.example ../0_genExampleData/R1_valid.example ../0_genExampleData/test.example ../0_genExampleData/R2_train.example ../2_latentSpaceMatching_and_matchingRefinement/idxP ../2_latentSpaceMatching_and_matchingRefinement/idxQ 0 $beta $beta
	The 0 here is the lambda, the same regularization term as MF.
	beta is the parameter that needs to be tuned by observing the validation RMSE.
	
	In this small data example, the RMSE of MF is already quite small (close to 0), so the result here is simply similar.


################ RUNNING on our dataset ################
	Download the data.zip from  http://www.csie.ntu.edu.tw/~r00922051/matching/ and unzip 
	For example, if you want to run our algorithm on (partial split, Yahoo! music), type the following commands:
		# generate data by the split scenario
		cd data/yahoo_partialSplit
		python gen.py
		cd ../..

		# if you had tried the small example data, remember to change the code back now

		#run MF
		cd code/1_MF
		g++ MF.cpp -o MF
		./MF 5 ../../data/yahoo_partialSplit/R1_train ../../data/yahoo_partialSplit/R1_valid ../../data/yahoo_partialSplit/R1_valid  &> log_R1 
		./MF 5 ../../data/yahoo_partialSplit/R2_train ../../data/yahoo_partialSplit/R2_valid ../../data/yahoo_partialSplit/R2_valid  &> log_R2 

		cat R1_train_vali_model.txt | ./toP.sh > R1_P
		cat R1_train_vali_model.txt | ./toQ.sh > R1_Q
		cat R2_train_vali_model.txt | ./toP.sh > R2_P
		cat R2_train_vali_model.txt | ./toQ.sh > R2_Q


		# run matching
		cd ../2_latentSpaceMatching_and_matchingRefinement
		# go inside matlab and type the following
		>> [idxP idxQ] = two_block_search(load('../../data/yahoo_partialSplit/R1_train'), load('../../data/yahoo_partialSplit/R1_valid'), load('../../data/yahoo_partialSplit/test'), load('../1_MF/R1_P'), load('../1_MF/R1_Q'), load('../../data/yahoo_partialSplit/R2_train'), load('../1_MF/R2_P'), load('../1_MF/R2_Q'), 20, 500);
		>> dlmwrite('idxP', idxP);
		>> dlmwrite('idxQ', idxQ);
		>> exit

		
		# rating prediction from matching
		cd ../3_ratingPredictionWithMatching
		g++ combinedMF.cpp -o combinedMF
		beta=40
		./combinedMF ../../data/yahoo_partialSplit/R1_train ../../data/yahoo_partialSplit/R1_valid ../../data/yahoo_partialSplit/test ../../data/yahoo_partialSplit/R2_train ../2_latentSpaceMatching_and_matchingRefinement/idxP ../2_latentSpaceMatching_and_matchingRefinement/idxQ 5 $beta $beta

